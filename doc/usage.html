<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Using the GEDCOM parser library</title>
  
                                                              
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"></head><body text="#000000" bgcolor="#ffffff" link="#000099" vlink="#990099" alink="#000099">
                 
<h1 align="center">Using the GEDCOM parser library</h1>
         <br>
                 
<h2>Index</h2>
               
<ul>
          <li><a href="#anchor">Overview</a></li>
          <li><a href="#Error_handling">Error handling</a></li>
          <li><a href="#Data_callback_mechanism">Data callback mechanism</a></li>
                               
  <ul>
            <li><a href="#Start_and_end_callbacks">Start and end callbacks</a></li>
            <li><a href="#Default_callbacks">Default callbacks</a></li>
                               
  </ul><li><a href="#Support_for_writing_GEDCOM_files">Support for writing GEDCOM files</a></li>
  <ul>
    <li><a href="#Opening_and_closing_files">Opening and closing files</a></li>
    <li><a href="#Controlling_some_settings">Controlling some settings</a></li>
    <li><a href="#Writing_data">Writing data</a><br>
    </li>
  </ul>
<li><a href="#Other_API_functions">Other API functions</a></li>
                           
  <ul>
           <li><a href="#Debugging">Debugging</a></li>
           <li><a href="#Error_treatment">Error treatment</a></li>
           <li><a href="#Compatibility_mode">Compatibility mode</a></li>
                           
  </ul>
    <li><a href="#Converting_character_sets">Converting character sets</a></li>
    <li><a href="#Support_for_configure.in">Development support</a><br>
<br>
     </li>
           <li><a href="interface.html">Interface details of the callback parser</a></li><li><a href="gom.html">C object model</a><br>
            </li>

               
</ul>
               
<hr width="100%" size="2">         
<h2><a name="Overview"></a>Overview<br>
         </h2>          The GEDCOM
parser library provides two interfaces. &nbsp;At the one hand, it can be
used as a callback-based parser (comparable      to the SAX interface of
XML); at the other hand, the parser can be used to convert the GEDCOM file
into an object model (comparable to the DOM interface of XML). &nbsp;It comes
with:<br>
                 
<ul>
           <li>a library (<code>libgedcom.so</code>), to be linked in the 
application     program, which implements the callback parser</li>
           <li>a header file (<code>gedcom.h</code>), to be used in the sources 
   of  the application program</li>
       <li>a header file (<code>gedcom-tags.h</code>) that is also installed, 
  but that is automatically included via <code>gedcom.h</code></li></ul>Additionally, if you want to use the GEDCOM C object model, the following should be used (note that <code>libgedcom.so</code> is also needed in this case, because the object model uses the callback parser internally):<br>
<ul>
  <li>a library (<code>libgedcom_gom.so</code>), to be linked in the application program, which implements the C object model</li>
  <li>a header file (<code>gom.h</code>), to be used in the sources of the application program<br>
  </li>

                 
</ul>There is a separate script to help with library and compilation flags, see the <a href="#Support_for_configure.in">development support</a>.<br>
<br>
Next to these, there is also a data directory in <code>$PREFIX/share/gedcom-parse</code>
          that contains some additional stuff, but which is not immediately 
 important    at first. &nbsp;I'll leave the description of the data directory 
 for later.<br>
         <br>
         The very simplest call of the gedcom callback parser is simply the following
  piece   of code (include of the <code>gedcom.h</code> header is assumed, as everywhere
in  this manual):<br>
                 
<blockquote><code>int result;<br>
  ...<br>
    <b>gedcom_init</b>();<br>
         ...<br>
         result = <b>gedcom_parse_file</b>("myfamily.ged");<br>
           </code>   </blockquote>
         Although this will not provide much information, one thing it does 
 is  parse  the entire file and return the result. &nbsp;The function returns
  0 on success  and 1 on failure. &nbsp;No other information is available
using   this function  only.<br>
<br>
Alternatively, programs using the C object model should use the following (in this case, the inclusion of both <code>gedcom.h</code> and <code>gom.h</code> is required):<br>
  
<blockquote><code>int result;<br>
  ...<br>
    <b>gedcom_init</b>();<br>
         ...<br>
         result = <b>gom_parse_file</b>("myfamily.ged");<br>
           </code>   </blockquote>
The call to <code>gom_parse_file</code> will build the C object model, which is then a complete representation of the GEDCOM file.<br>
<br>
No matter which of the interfaces you use, the call to <code>gedcom_init</code>() should be one of the first calls 
in your program. &nbsp;The requirement is that it should come before the first
call to <code>iconv_open</code> (part of the generic character set conversion
feature) in the program, either by your program itself, or indirectly by
the library calls it makes. &nbsp;Practically, it should e.g. come before
 any calls to any GTK functions, because GTK uses <code>iconv_open</code>
 in its initialization.<br>
&nbsp; <br>
For the same reason it is also advised to put
the <code>-lgedcom</code> option
on the linking of the program as the last option, so that its initialization
code is run first. &nbsp;In the case of using the C object model, the linking
options should be: <code>-lgedcom_gom -lgedcom</code><br>
          <br>The function <code>gedcom_init()</code> also initializes locale handling by calling <code>setlocale(LC_ALL, "")</code>, in case the application would not do this (it doesn't hurt for the application to do the same).<br>
&nbsp;<br>
The next sections will refine this piece of code to be able to have
 meaningful errors   and the actual data that is in the file.<br>
                           
<hr width="100%" size="2">                       
<h2><a name="Error_handling"></a>Error handling</h2>The library can be used in several different circumstances, both
terminal-based     as GUI-based. &nbsp;Therefore, it leaves the actual display
of the error    message up to the application. &nbsp;For this, the application
needs to  register  a callback before parsing the GEDCOM file, which will
be called  by the library   on errors, warnings and messages.<br>
          <br>
        A typical piece of code would be (<code>gom_parse_file</code> would be called in case the C object model is used):<br>
                           
<blockquote><code>void <b>my_message_handler</b> (Gedcom_msg_type type,  
 char *msg)<br>
        {<br>
        &nbsp; ...<br>
        }<br>
        ...<br>
            <b>gedcom_set_message_handler</b>(my_message_handler);<br>
        ...<br>
        result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
            </blockquote>
        In the above piece of code, <code>my_message_handler</code> is the
 callback    that will be called for errors (<code>type=ERROR</code>), warnings
 (<code>type=WARNING</code>) and messages (<code>type=MESSAGE</code>). &nbsp;The
   callback must have the signature as in the example. &nbsp;For errors,
the        <code> msg</code> passed to the callback will have the format:<br>
                                       
<blockquote><code>Error on line</code> <i>&lt;lineno&gt;</i>: <i>&lt;actual_message&gt;</i><br>
              </blockquote>
        Note that the entire string will be properly internationalized, and 
 encoded   in UTF-8 (<a href="encoding.html">Why UTF-8?</a>). &nbsp;Also, 
no newline   is appended, so that the application program can use it in any 
way it wants.   &nbsp;Warnings are similar, but use "Warning" instead of "Error".
&nbsp;Messages   are plain text, without any prefix.<br>
              <br>
        With this in place, the resulting code will already show errors and 
 warnings   produced by the parser, e.g. on the terminal if a simple <code>
   printf</code>      is used in the message handler.<br>
                                                   
<hr width="100%" size="2">                                            
<h2><a name="Data_callback_mechanism"></a>Data callback mechanism</h2>
        The most important use of the parser is of course to get the data 
out   of  the GEDCOM file. &nbsp;This section focuses on the callback mechanism (see <a href="gom.html">here</a> for the C object model). &nbsp;In fact, the mechanism involves two levels.<br>
              <br>
        The primary level is that each of the sections in a GEDCOM file is
 notified    to the application code via a "start element" callback and an
 "end element"    callback (much like in a SAX interface for XML), i.e. when
 a line containing    a certain tag is parsed, the "start element" callback
 is called for that   tag, and when all its subordinate lines with their
tags  have been processed,   the "end element" callback is called for the
original  tag. &nbsp;Since GEDCOM    is hierarchical, this results in properly
nested  calls to appropriate "start    element" and "end element" callbacks (note: see <a href="#Compatibility_mode">compatibility handling</a>).<br>
              <br>
        However, it would be typical for a genealogy program to support only
  a  subset  of the GEDCOM standard, certainly a program that is still under
  development.   &nbsp;Moreover, under GEDCOM it is allowed for an application
  to define its  own tags, which will typically not &nbsp;be supported by
another  application.   &nbsp;Still, in that case, data preservation is important;
  it would hardly   be accepted that information that is not understood by
 a certain program  is just removed.<br>
              <br>
        Therefore, the second level of callbacks involves a "default callback". 
   &nbsp;An application needs to subscribe to callbacks for tags it does support,
   and need to provide a "default callback" which will be called for tags
it   doesn't support. &nbsp;The application can then choose to just store
the  information that comes via the default callback in plain textual format.<br>
              <br>
        After this introduction, let's see what the API looks like...<br>
              <br>
                                                   
<h3><a name="Start_and_end_callbacks"></a>Start and end callbacks</h3>
                                                   
<h4><i>Callbacks for records</i> <br>
              </h4>
        As a simple example, we will get some information from the header 
of  a  GEDCOM  file. &nbsp;First, have a look at the following piece of code:<br>
                                                   
<blockquote><code>Gedcom_ctxt <b>my_header_start_cb</b> (Gedcom_rec rec,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int level,    <br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gedcom_val xref, <br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char *tag, <br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char *raw_value,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int parsed_tag, <br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gedcom_val parsed_value)<br>
        {<br>
        &nbsp; printf("The header starts\n");<br>
        &nbsp; return (Gedcom_ctxt)1;<br>
        }<br>
                <br>
        void <b>my_header_end_cb</b> (Gedcom_rec rec, Gedcom_ctxt self)<br>
        {<br>
        &nbsp; printf("The header ends, context is %d\n", (int)self); &nbsp;
 /* context    will print as "1" */<br>
        }<br>
                <br>
        ...<br>
                <b>gedcom_subscribe_to_record</b>(REC_HEAD, my_header_start_cb, 
   my_header_end_cb);<br>
        ...<br>
        result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
                </blockquote>
           Using the <code>gedcom_subscribe_to_record</code> function, the
 application    requests to use the specified callbacks as start and end
callback.  The end   callback is optional: you can pass <code>NULL</code>
 if you are  not interested   in the end callback. &nbsp;The identifiers
to use as first  argument to the   function (here <code>REC_HEAD</code>)
are described in the <a href="interface.html#Record_identifiers">     interface
details</a> . &nbsp;These are also passed as first argument in the callbacks (the <code>Gedcom_rec</code> argument).<br>
                <br>
        From the name of the function it becomes clear that this function 
is  specific   to complete records. &nbsp;For the separate elements in records
  there is  another function, which we'll see shortly. &nbsp;Again, the callbacks
  need  to have the signatures as shown in the example.<br>
                <br>
        The <code>Gedcom_ctxt</code> type that is used as a result of the 
start    callback and as an argument to the end callback is vital for passing 
context    necessary for the application. &nbsp;This type is meant to be opaque;
in   fact, it's a void pointer, so you can pass anything via it. &nbsp;The
important    thing to know is that the context that the application returns
in the start    callback will be passed in the end callback as an argument,
and as we will    see shortly, also to all the directly subordinate elements
of the record.<br>
             <br>
     The <code>tag</code> is the GEDCOM tag in string format, the <code>parsed_tag</code>
      is an integer, for which symbolic values are defined as <code>TAG_HEAD,</code>
      <code>TAG_SOUR,</code> <code>TAG_DATA,</code> ... and <code>USERTAG 
</code><code></code>    for the application-specific tags. &nbsp;These values 
are defined in the   header <code>gedcom-tags.h</code> that is installed, 
and included via <code>    gedcom.h</code> (so no need to include <code>gedcom-tags.h</code>
  yourself).<br>
                <br>
        The example passes a simple integer as context, but an application
 could    e.g. pass a <code>struct</code> (or an object in a C++ application)
 that will contain the information for the    header. &nbsp;In the end callback,
 the application could then e.g. do some    finalizing operations on the
<code>  struct</code> to put it in its database.<br>
                <br>
        (Note that the <code>Gedcom_val</code> type for the <code>xref</code>
     and <code>parsed_value</code> arguments  was not discussed, see further
  for this)<br>
                <br>
                                                               
<h4><i>Callbacks for elements</i></h4>
        We will now retrieve the SOUR field (the name of the program that 
wrote    the file) from the header:<br>
                                                               
<blockquote><code>Gedcom_ctxt <b>my_header_source_start_cb</b>(Gedcom_elt &nbsp;elt,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gedcom_ctxt
    parent,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 
  &nbsp;  &nbsp; &nbsp; level,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* &nbsp; 
  &nbsp;  &nbsp; tag,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* &nbsp; 
  &nbsp;  &nbsp; raw_value,<br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp;
 &nbsp;  &nbsp; &nbsp; parsed_tag,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gedcom_val 
  &nbsp;parsed_value)<br>
        {<br>
        &nbsp; char *source = GEDCOM_STRING(parsed_value);<br>
        &nbsp; printf("This file was written by %s\n", source);<br>
        &nbsp; return parent;<br>
        }<br>
                  <br>
        void <b>my_header_source_end_cb</b>(Gedcom_elt &nbsp;elt,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Gedcom_ctxt parent,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp;Gedcom_ctxt self,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp;Gedcom_val &nbsp;parsed_value)<br>
        {<br>
        &nbsp; printf("End of the source description\n");<br>
        }<br>
                  <br>
        ...<br>
                  <b>gedcom_subscribe_to_element</b>(ELT_HEAD_SOUR,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; my_header_source_start_cb,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp;  &nbsp; &nbsp; &nbsp; my_header_source_end_cb);<br>
        ...<br>
        result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
                  </blockquote>
        The subscription mechanism for elements is similar, only the signatures 
   of the callbacks differ. &nbsp;The signature for the start callback shows 
   that the context of the parent line (here e.g. the <code>struct</code>
  that describes   the header) is passed to this start callback. &nbsp;The
 callback itself returns  here in this example the same context, but this
can be its own context object of course. &nbsp;The end callback is called
with both the context of the parent and the context of itself, which in this
example will be the same. &nbsp;Again,  the list of identifiers to use as
a first argument for the subscription function  are detailed in the <a href="interface.html#Element_identifiers">  interface  details</a> . &nbsp;Again, these are passed as first argument in the callback (the <code>Gedcom_elt</code> argument).<br>
                  <br>
        If we look at the other arguments of the start callback, we see the 
 level   number (the initial number of the line in the GEDCOM file), the tag
 (e.g.   "SOUR"), and then a raw value, a parsed tag and a parsed value. &nbsp;The
  raw value is just the raw string that occurs as value on the line next
to   the tag (in UTF-8 encoding). &nbsp;The parsed value is the meaningful
value   that is parsed from that raw string. &nbsp;The parsed tag is described
in   the section for record callbacks above.<br>
                  <br>
        The <code>Gedcom_val</code> type is meant to be an opaque type. &nbsp;The
    only thing that needs to be known about it is that it can contain specific
    data types, which have to be retrieved from it using pre-defined macros.
   &nbsp;These data types are described in the <a href="interface.html#Gedcom_val_types">     interface details</a>.     
     <br>
                 <br>
        Some extra notes:<br>
                                                                        
  
<ul>
                    <li>The <code>Gedcom_val</code> argument of the end callback
    is used to pass 'complete' values, e.g. the full text of a note. &nbsp;See
 the&nbsp;<a href="file:///home/verthezp/src/external/gedcom-parse/doc/interface.html#Record_identifiers">interface details</a>
  for the exact type of this argument.</li>
                    <li>There are also two <code>Gedcom_val</code> arguments
 in the   start callback for records. &nbsp;The first one (<code>xref</code>
  ) contains the <code>xref_value</code> corresponding to the cross-reference
 (or <code>NULL</code> if there isn't one), the second one (<code>parsed_value</code>
  ) contains the value that is parsed from the <code>raw_value</code>. &nbsp;See
 the&nbsp;<a href="interface.html#Record_identifiers">interface details</a>
  .</li>
                                                                        
  
</ul>
                                                                        
  
<h3><a name="Default_callbacks"></a>Default callbacks<br>
                  </h3>
        As described above, an application doesn't always implement the entire
   GEDCOM spec, and application-specific tags may have been added by other
 applications.  &nbsp;To preserve this extra data anyway, a default callback
 can be registered  by the application, as in the following example:<br>
                                                               
<blockquote><code>void <b>my_default_cb</b> (Gedcom_elt elt, Gedcom_ctxt parent,   int level,
 char* tag, char* raw_value, int parsed_tag)<br>
       {<br>
       &nbsp; ...<br>
       }<br>
                   <br>
       ...<br>
                   <b>gedcom_set_default_callback</b>(my_default_cb);<br>
       ...<br>
       result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
                   </blockquote>
                  This callback has a similar signature as the previous ones, 
  but  it doesn't contain a parsed value. &nbsp;However, it does contain the
  parent  context, that was returned by the application for the most specific
  containing  tag that the application supported.<br>
                   <br>
       Suppose e.g. that this callback is called for some tags in the header
  that  are specific to some other application, then our application could
 make sure  that the parent context contains the struct or object that represents 
  the  header, and use the default callback here to add the level, tag and 
 raw_value  as plain text in a member of that struct or object, thus preserving 
 the information.  &nbsp;The application can then write this out when the 
data is saved again  in a GEDCOM file. &nbsp;To make it more specific, consider 
  the following example:<br>
                                                                         
<blockquote><code>struct header {<br>
       &nbsp; char* source;<br>
       &nbsp; ...<br>
       &nbsp; char* extra_text;<br>
       };<br>
                     <br>
       Gedcom_ctxt my_header_start_cb(Gedcom_rec rec, int level, Gedcom_val xref, char* tag,
  char *raw_value,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int parsed_tag, Gedcom_val parsed_value)<br>
       {<br>
       &nbsp; struct header head = my_make_header_struct();<br>
       &nbsp; return (Gedcom_ctxt)head;<br>
       }<br>
                     <br>
       void my_default_cb(Gedcom_elt elt, Gedcom_ctxt parent, int level, char* tag, char* 
raw_value,   int parsed_tag)<br>
       {<br>
       &nbsp; struct header head = (struct header)parent;<br>
       &nbsp; my_header_add_to_extra_text(head, level, tag, raw_value);<br>
       }<br>
                     <br>
       gedcom_set_default_callback(my_default_cb);<br>
       gedcom_subscribe_to_record(REC_HEAD, my_header_start, NULL);<br>
       ...<br>
       result = gedcom_parse_file(filename);</code><br>
                     </blockquote>
       Note that the default callback will be called for any tag that isn't 
 specifically   subscribed upon by the application, and can thus be called 
 in various contexts.   &nbsp;For simplicity, the example above doesn't take 
 this into account (the                 <code>parent</code> could be of different 
 types, depending  on the context).<br>
                 <br>
   Note also that the default callback is not called when the parent context
 is&nbsp;<code>NULL</code><code></code>. &nbsp;This is e.g. the case if none
 of the "upper" tags has been subscribed upon.<br>
                                                                        
          
<hr width="100%" size="2"><br>
<h2><a name="Support_for_writing_GEDCOM_files"></a>Support for writing GEDCOM files</h2>
The Gedcom parser library also contains functions to writing GEDCOM files.
&nbsp;Similar as for the parsing itself, there are two interfaces: an interface
which is very basic, and requires you to call a function for each line in
the GEDCOM file, and an interface which just dumps the Gedcom object model
to a file in one shot (if you use the Gedcom object model).<br>
<br>
Again, this section focuses on the basic interface, the Gedcom object model interface is described <a href="gom.html#Writing_the_object_model_to_file">here</a>.<br>
<br>
<h3><a name="Opening_and_closing_files"></a>Opening and closing files</h3>
The basic functions for opening and closing Gedcom files for writing are the following:<br>
<code></code>
<blockquote><code>Gedcom_write_hndl <b>gedcom_write_open</b> (const char* filename);<br>
int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gedcom_write_close</b> (Gedcom_write_hndl hndl, int* total_conv_fails);<br></code></blockquote>
The function <code>gedcom_write_open</code> takes a parameter the name of
the file to write, and returns a write handle, which needs to be used in
subsequent functions. &nbsp;It returns <code>NULL</code> in case of errors.<br>
<br>
The function <code>gedcom_write_close</code> takes, next to the write handle,
an integer pointer as parameter. &nbsp;If you pass an actual pointer for
this, the function will write in it the total number of conversion failures;
you can pass <code>NULL</code> if you're not interested. &nbsp;The function returns 0 in case of success, non-zero in case of failure.<br>
<br>
<h3><a name="Controlling_some_settings"></a>Controlling some settings<br>
</h3>
Note that by default the file is written in the same encoding as the read file was in. &nbsp;You can change
this by calling the following function <i>before</i> calling <code>gedcom_write_open</code>, i.e. it affects all files that are opened after it is being called:<code></code><code><br>
</code>
<blockquote><code>int <b>gedcom_write_set_encoding</b> (Enc_from from, const char* charset, Encoding width, Enc_bom bom);<br></code></blockquote>The <code>from</code> parameter indicates how you want the encoding to be set:<br>
<ul>
  <li><b><code>ENC_FROM_FILE</code></b>: The same as the read file was in (this is the default).</li>
  <li><b><code>ENC_FROM_SYS</code></b>: Not a valid value here, see below for <code>gedcom_write_set_terminator</code><br>
  </li>
  <li><b><code>ENC_MANUAL</code></b>: From the values given in the following parameters.</li>
</ul>
When <code>ENC_FROM_FILE</code><b> </b>is selected, the other parameters in the function are ignored (they can be passed as 0). &nbsp;When <code>ENC_MANUAL</code> is chosen, the meaning of the other parameters is as follows:<br>
<br>
The valid <code>charset</code> values are given in the first column in the file <code>gedcom.enc</code> in the data directory of gedcom-parse (<code>$PREFIX/share/gedcom-parse</code>).
&nbsp;The character sets UNICODE, ASCII and ANSEL are always supported (these
are standard for GEDCOM), as well as ANSI (not standard), but there may be
others.<br>
<br>
The <code>width</code> parameter takes one of the following values:<br>
<ul>
</ul>
<ul>
  <li><code><b>ONE_BYTE</b></code>: This should be used for all character sets except UNICODE.</li>
  <li><code><b>TWO_BYTE_HILO</b></code>: High-low encoding for UNICODE (i.e. big-endian)</li>
  <li><code><b>TWO_BYTE_LOHI</b></code>: Low-high encoding for UNICODE (i.e. little-endian)</li>
</ul>
The <code>bom</code> parameter determines whether a byte-order-mark should
be written in the file in case of UNICODE encoding (usually preferred because
it then clearly indicates the byte ordering). &nbsp;It takes one of the following
values:<br>
<ul>
  <li><code><b>WITHOUT_BOM</b></code></li>
  <li><code><b>WITH_BOM</b></code></li>
</ul> For both these parameters you can pass 0 for non-UNICODE encodings,
since that corresponds to the correct values (and is ignored anyway). &nbsp;The 
function returns 0 in case of success, non-zero in case of error. &nbsp;Note
that you still need to pass the correct charset value for the HEAD.CHAR tag,
otherwise you will get a warning, and the value will be forced to the correct
value.<br>
<br>
Further, it is possible to control the kind of line terminator that is used, via the following function (also to be used before <code>gedcom_write_open</code>):<br>
<blockquote><code>int <b>gedcom_write_set_line_terminator</b> (Enc_from from, Enc_line_end end);<br></code></blockquote>The values for the <code>from</code> parameter are given above. &nbsp;The value <b><code>ENC_FROM_SYS</code></b>
is valid here, and means that the normal terminator for the current system
is used (the second parameter of the function is then ignored). &nbsp; This
is the default for this setting.<br>
<br>
The <code>end</code> parameter takes one of the following values:<br>
<ul>
  <li><b><code>END_CR</code></b>: only carriage return ("/r") (system value for Macintosh)</li>
  <li><b><code>END_LF</code></b>: only line feed ("/n") (system value for Unix, Mac OS X)</li>
  <li><b><code>END_CR_LF</code></b>: first carriage return, then line feed ("/r/n") (system value for DOS, Windows)</li>
  <li><b><code>END_LF_CR</code></b>: first line feed, then carriage return ("/n/r")</li>
</ul>
By default, this is set to the appropriate line terminator on the current
platform, so it only needs to be changed if there is some special reason
for it.<br>
<h3><a name="Writing_data"></a>Writing data<br>
</h3>
For actually writing the data, the principle is that every line in the GEDCOM
file to write corresponds to a call to one of the following functions, except
that CONT/CONC lines can be automatically taken care of. &nbsp;Note that
the resulting GEDCOM file should conform to the GEDCOM standard. &nbsp;Several
checks are built in already, and more will follow, to force this. &nbsp;There
is no compatibility mode for writing GEDCOM files (and probably never will be).<br>
<br>
In general, each of the following functions expect their input in UTF-8 encoding (see also <a href="#Converting_character_sets">here</a>). &nbsp;If this is not the case, errors will be returned.<br>
<br>
Note that for examples of using these functions you can look at the sources for the Gedcom object model (e.g. the function <code>write_header</code> in <code>gom/header.c</code>).<br>
<h4>Records</h4>
For writing lines corresponding to records (i.e. on level 0), the following function is available:
<blockquote><code>int <b>gedcom_write_record_str</b> (Gedcom_write_hndl hndl, Gedcom_rec rec, const char* xrefstr, const char* value);<br></code></blockquote>
The <code>hndl</code> parameter is the write handle that was returned by <code>gedcom_write_open</code>. &nbsp;The <code>rec</code> parameter is one of the identifiers given in the first column in <a href="interface.html#Record_identifiers">this table</a> (except <code>REC_USER</code>: see below). &nbsp;The <code>xrefstr</code> and <code>val</code> parameters are respectively the cross-reference key of the record (something like '<code>@FAM01@</code>'), and the value of the record line, which should be <code>NULL</code> for some record types, according to the same table.<br>
<h4>Elements</h4>
For writing lines corresponding to elements (inside records, i.e. on a level
bigger than 0), the following functions are available, depending on the data
type:
<blockquote><code>int <b>gedcom_write_element_str</b> &nbsp;(Gedcom_write_hndl hndl, Gedcom_elt elt, int parsed_tag, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int parent_rec_or_elt, const char* value);<br>
i</code><code>nt <b>gedcom_write_element_xref</b> (Gedcom_write_hndl hndl, Gedcom_elt elt, int parsed_tag, <br> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int parent_rec_or_elt, const struct xref_value*
value);</code><br>
  <code>int <b>gedcom_write_element_date</b> (Gedcom_write_hndl hndl, Gedcom_elt elt, int parsed_tag, <br> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int parent_rec_or_elt, const struct date_value*
value);</code><br>
  <code>i</code><code>nt <b>gedcom_write_element_age&nbsp;</b> (Gedcom_write_hndl hndl, Gedcom_elt elt, int parsed_tag, <br> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int parent_rec_or_elt, const struct age_value*
value);</code><br>
</blockquote>
<blockquote><code></code></blockquote>
These functions only differ in the type of the last argument, which is the value of the element.<br>
<br>
The <code>hndl</code> parameter is again the write handle returned by <code>gedcom_write_open</code>. &nbsp;The <code>elt</code> parameter is one of the identifiers given in the first column in <a href="interface.html#Element_identifiers">this table</a> (except <code>ELT_USER</code>: see below). &nbsp;The <code>parent_rec_or_elt</code> is the corresponding <code>rec</code> or <code>elt</code>
identifier of the logically enclosing statement: this will determine the
level number written on the line, as the level number of the parent + 1.<br>
<br>
Some of the identifiers can actually stand for different tags. &nbsp;For this reason, the <code>parsed_tag</code> has to be passed for some of them. &nbsp;This parsed tag is the same as was returned by the callback functions defined <a href="#Start_and_end_callbacks">above</a>, and is an identifier of the form <code>TAG_<i>name</i></code>. &nbsp;This parameter is needed whenever the second column in <a href="interface.html#Element_identifiers">this table</a> shows several possible tags (this is e.g. the case for <code>ELT_SUB_FAM_EVT</code>).<br>
<br>
Note that for writing a date value, the given value should be valid, i.e.
all its struct fields filled in properly and consistent. &nbsp;This can be
done by calling <code>gedcom_normalize_date</code> (see <a href="interface.html#date">here</a>).<br>
<h4>User-defined tags</h4>
For user-defined tags (tags starting with an underscore), there are separate functions, again depending on the data type:<code></code>
<blockquote><code>int <b>gedcom_write_user_str</b> &nbsp;(Gedcom_write_hndl hndl, int level, const char* tag, const char* xrefstr,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const char* value);<br>
i</code><code>nt <b>gedcom_write_user_xref</b> (Gedcom_write_hndl hndl, </code><code>int level, const char* tag, const char* xrefstr,</code><br>
  <code> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; const struct xref_value* value);</code><br>
  <code></code></blockquote>
In the case of user-defined tags, the level and tag string are passed verbatim
(not controlled by the library). &nbsp;This allows to write any extra data
that doesn't use a standard tag, but is only allowed for tags starting with
an underscore.<br>
<hr width="100%" size="2">                                              
                              
<h2><a name="Other_API_functions"></a>Other API functions<br>
                     </h2>

       Although the above describes the basic interface of the gedcom parser, there 
 are   some other functions that allow to customize the behaviour of the library.
   &nbsp;These will be explained in the current section.<br>
                                                                        
          
<h3><a name="Debugging"></a>Debugging</h3>
       The library can generate various debugging output, not only from itself, 
   but also the debugging output generated by the yacc parser. &nbsp;By default, 
   no debugging output is generated, but this can be customized using the 
following   function:<br>
                                                                        
          
<blockquote><code>void <b>gedcom_set_debug_level</b> (int level,   FILE*
trace_output)</code><br>
                       </blockquote>
       The <code>level</code> can be one of the following values:<br>
                                                                        
                    
<ul>
                         <li>0: &nbsp;no debugging information (this is the 
 default)</li>
                         <li>1: &nbsp;only debugging information from libgedcom 
   itself</li>
                         <li>2: &nbsp;debugging information from libgedcom
 and   yacc</li>
                                                                        
                    
</ul>
       If the <code>trace_output</code> is <code>NULL</code>, debugging information 
   will be written to <code>stderr</code>, otherwise the given file handle 
 is  used (which must be open).<br>
                       <br>
                                                                        
                    
<h3><a name="Error_treatment"></a>Error treatment</h3>
       One of the previous sections already described the callback to be
registered    to get error messages. &nbsp;The library also allows to customize
what happens   on an error, using the following function:<br>
                                                                        
                    
<blockquote><code>void <b>gedcom_set_error_handling</b> (Gedcom_err_mech 
 mechanism)</code><br>
                         </blockquote>
       The <code>mechanism</code> can be one of:<br>
                                                                        
                              
<ul>
                           <li><code>IMMED_FAIL</code>: immediately fail
the   parsing  on an error (this is the default)</li>
                           <li><code>DEFER_FAIL</code>: continue parsing
after    an error, but return a failure code eventually</li>
                           <li><code>IGNORE_ERRORS</code>: continue parsing 
 after   an error, return success always</li>
                                                                        
                              
</ul>
       This doesn't influence the generation of error or warning messages,
 only   the behaviour of the parser and its return code.<br>
                         <br>
                                                                        
                              
<h3><a name="Compatibility_mode"></a>Compatibility mode<br>
                         </h3>
       Applications are not necessarily true to the GEDCOM spec (or use a 
different    version than 5.5). &nbsp;The intention is that the library is 
resilient  to  this, and goes in compatibility mode for files written by specific
programs    (detected via the HEAD.SOUR tag). &nbsp;This compatibility mode
can be enabled   and disabled via the following function:<br>
                                                                        
                              
<blockquote><code>void <b>gedcom_set_compat_handling</b>      (int enable_compat)</code><br>
                           </blockquote>
       The argument can be:<br>
                                                                        
                                        
<ul>
                             <li>0: disable compatibility mode</li>
                             <li>1: allow compatibility mode (this is the 
default)<br>
                             </li>
                                                                        
                                        
</ul>
       Currently, there is (some) compatibility for:<br>
<ul>
  <li>ftree</li>
  <li>Lifelines (3.0.2)</li>
  <li>Personal Ancestral File (PAF), version 2, 4 and 5</li>
  <li>Family Origins</li>
  <li>EasyTree</li>
</ul>
The following function allows to set some options for the compatibility handling:<br>
<blockquote><code>void <b>gedcom_set_compat_options</b>      (Gedcom_compat options)</code><br>
                           </blockquote>
The parameter can be an OR'ed combination of the following options:<br>
<ul>
  <li><code>COMPAT_ALLOW_OUT_OF_CONTEXT</code></li>
</ul>
<blockquote>
  <blockquote>In some compatibility cases, tags are coming out-of-order,
i.e. their start element callback would have to come after the end element
callback of the parent tag. &nbsp;E.g. instead of the standard GEDCOM<br>
    <blockquote><code>1 DATE ...<br>
2 TIME ...</code><br>
    </blockquote>
the genealogy program has generated something like:<br>
    <blockquote><code>1 DATE ...<br>
1 TIME ...</code><br>
    </blockquote>
This can give a problem if your end element callbacks free some resources. &nbsp;<br>
    <br>
If your program can handle elements out of context, you can enable this option.
&nbsp;By default it is disabled, and so the values of these out-of-context
tags are lost (the parser generates a warning if this is the case). &nbsp;Note:
currently the Gedcom object model in C has this option disabled too, although
this will change in the future.<br>
  </blockquote>
</blockquote>
<br>

                         
<hr width="100%" size="2">                       
<h2><a name="Converting_character_sets"></a>Converting character sets</h2>
   All strings passed by the GEDCOM parser to the application are in UTF-8
 encoding. &nbsp;Typically, an application needs to convert this to something
 else to be able to display it.<br>
                       <br>
   The most common case is that the output character set is controlled by 
the <code>locale</code> mechanism (i.e. via the <code>LANG</code>, <code>
 LC_ALL</code>  or <code>LC_CTYPE</code> environment variables), which also 
controls the <code>gettext</code>  mechanism in the application. &nbsp;<br>
                       <br>With<code>
gedcom-parse</code>   comes a library implementing help functions for UTF-8 encoding (<code></code>see
the <a href="utf8tools.html">documentation</a> for this library).<br>
                                                                        
                         
<hr width="100%" size="2">                                              
 
<h2><a name="Support_for_configure.in"></a>Development support</h2>
<h3>Macro for configure.in<br>
</h3>
There
is a macro available for use in configure.in for applications that are using
autoconf to configure their sources. &nbsp;The following macro checks whether
the Gedcom parser library is available and whether its version is high enough:<br>
<blockquote><code>AM_PATH_GEDCOM_PARSER([<i>min_version</i>,[<i>action_if_found</i>,[<i>action_if_not_found,</i>[<i>modules</i>]]]])</code><br>
</blockquote>
All the arguments are optional and default to 0. &nbsp;E.g. to check for
version 1.34.2, you would put in configure.in the following statement:<br>
<blockquote><code>AM_PATH_GEDCOM_PARSER(1.34.2)</code><br>
</blockquote>Note that version numbers now contains three parts (since version
0.20.0: this is also the first version in which this macro is available).<br>
<br>
The macro also sets the variables <code>GEDCOM_CFLAGS</code> and <code>GEDCOM_LIBS</code> for use in Makefiles. &nbsp;Typically, this would be done as follows in a Makefile.am:<br>
<blockquote><code>bin_programs &nbsp; = myprg</code><br>
  <code>myprg_SOURCES &nbsp;= myprg.c foo.c bar.c<br>
INCLUDES &nbsp; &nbsp; &nbsp; = @GEDCOM_CFLAGS@<br>
LDADD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= @GEDCOM_LIBS@</code></blockquote>
If your program uses some extra modules, they can be passed as fourth argument
in the macro, so that the CFLAGS and LIBS are correctly filled in. &nbsp;Currently,
the only available module is <code>gom</code> (the Gedcom object model). &nbsp;For example:<br>
<blockquote><code>AM_PATH_GEDCOM_PARSER(0.21.2, , ,gom)</code><br>
</blockquote>
To be able to use this macro in the sources of your application, you have three options:<br>
<ul>
  <li>Put the file <code>m4/gedcom.m4</code> in your autoconf data directory (i.e. the path given by '<code>aclocal --print-ac-dir</code>', usually <code>/usr/share/aclocal</code>). &nbsp;You can do this automatically by going into the m4 subdirectory and typing '<code>make install-m4</code>'.<br>
    <br>
  </li>
  <li>If you're using autoconf, but not automake, copy the contents of <code>m4/gedcom.m4</code> in the <code>aclocal.m4</code> file in your sources.<br>
    <br>
  </li>
  <li>If you're using automake, copy the contents of <code>m4/gedcom.m4</code> in the <code>acinclude.m4</code> file in your sources.<br>
  </li>
</ul>
<br>
There are three preprocessor symbols defined for version checks in the
 header (but their direct use is deprecated: please use the macro above):<br>
                                                     
<ul>
                                                     <li><code>GEDCOM_PARSE_VERSION_MAJOR</code></li>
                                                     <li><code>GEDCOM_PARSE_VERSION_MINOR</code></li>
                                                     <li><code>GEDCOM_PARSE_VERSION</code><br>
                                                     </li>
                                                     
</ul>
   The last one is equal to <code>(GEDCOM_PARSE_VERSION_MAJOR * 1000) + GEDCOM_PARSE_VERSION_MINOR.</code> As you see, this only checked the major and minor version, not the patch number, so this is obsolete.<br>
<br>
<h3>Compilation and linking flags</h3>
Similar to other libraries, the GEDCOM parse library installs a script <code>gedcom-config</code> to help with compilation and linking flags for programs that don't use autoconf/automake.<br>
<br>
To get compilation flags for your program, use (depending on whether you
only use the callback parser, or also the GEDCOM object model):
<blockquote><code>gedcom-config --cflags<br>
gedcom-config --cflags gom</code><br>
</blockquote>
Similarly, to get linking flags, use one of the following:
<blockquote><code>gedcom-config --libs<br>
gedcom-config --libs gom</code><br>
</blockquote>


     
<hr width="100%" size="2">                                              
                                       
<pre><font size="-1">$Id$<br>$Name$</font><br></pre>
                                                                        
                  
<pre>                    </pre>
                                                                        
                                                        
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body></html>