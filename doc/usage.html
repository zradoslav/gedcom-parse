<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Using the GEDCOM parser library</title>
      
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
</head>
<body>
 
<h1 align="center">Using the GEDCOM parser library</h1>
 <br>
 
<h2>Index</h2>
<ul>
  <li><a href="#anchor">Overview</a></li>
  <li><a href="#Error_handling">Error handling</a></li>
  <li><a href="#Data_callback_mechanism">Data callback mechanism</a></li>
  <ul>
    <li><a href="#Start_and_end_callbacks">Start and end callbacks</a></li>
    <li><a href="#Default_callbacks">Default callbacks</a><br>
    </li>
  </ul>
</ul>
<hr width="100%" size="2"> 
<h2><a name="Overview"></a>Overview<br>
 </h2>
 The GEDCOM parser library is built as a callback-based parser (comparable 
to the SAX interface of XML). &nbsp;It comes with:<br>
 
<ul>
   <li>a library (<code>libgedcom.so</code>), to be linked in the application 
program</li>
   <li>a header file (<code>gedcom.h</code>), to be used in the sources of 
the application program</li>
 
</ul>
 Next to these, there is also a data directory in <code>$PREFIX/share/gedcom-parse</code>
  that contains some additional stuff, but which is not immediately important 
at first. &nbsp;I'll leave the description of the data directory for later.<br>
 <br>
 The very simplest call of the gedcom parser is simply the following piece 
of code (include of the gedcom header is assumed, as everywhere in this manual):<br>
 
<blockquote><code>int result;<br>
 ...<br>
 result = <b>gedcom_parse_file</b>("myfamily.ged");<br>
   </code>   </blockquote>
 Although this will not provide much information, one thing it does is parse
the entire file and return the result. &nbsp;The function returns 0 on success
and 1 on failure. &nbsp;No other information is available using this function
only.<br>
  <br>
The next sections will refine this to be able to have meaningful errors and
the actual data that is in the file.<br>
  <hr width="100%" size="2">   
  <h2><a name="Error_handling"></a>Error handling</h2>
Since this is a relatively simple topic, it is discussed before the actual
callback mechanism, although it also uses a callback...<br>
  <br>
The library can be used in several different circumstances, both terminal-based
as GUI-based. &nbsp;Therefore, it leaves the actual display of the error
message up to the application. &nbsp;For this, the application needs to register
a callback before parsing the GEDCOM file, which will be called by the library
on errors, warnings and messages.<br>
  <br>
A typical piece of code would be:<br>
  <blockquote><code>void <b>my_message_handler</b> (Gedcom_msg_type type,
char *msg)<br>
{<br>
&nbsp; ...<br>
}<br>
...<br>
    <b>gedcom_set_message_handler</b>(my_message_handler);<br>
...<br>
result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
    </blockquote>
In the above piece of code, <code>my_message_handler</code> is the callback
that will be called for errors (<code>type=ERROR</code>), warnings (<code>
type=WARNING</code>) and messages (<code>type=MESSAGE</code>). &nbsp;The
callback must have the signature as in the example. &nbsp;For errors, the
    <code>msg</code> passed to the callback will have the format:<br>
    <blockquote><code>Error on line</code> <i>&lt;lineno&gt;</i>: <i>&lt;actual_message&gt;</i><br>
      </blockquote>
Note that the entire string will be properly internationalized, and encoded
in UTF-8 (see "Why UTF-8?" &nbsp;<i>LINK TBD</i>). &nbsp;Also, no newline
is appended, so that the application program can use it in any way it wants.
&nbsp;Warnings are similar, but use "Warning" instead of "Error". &nbsp;Messages
are plain text, without any prefix.<br>
      <br>
With this in place, the resulting code will already show errors and warnings
produced by the parser, e.g. on the terminal if a simple <code>printf</code>
 is used in the message handler.<br>
      <hr width="100%" size="2">
      <h2><a name="Data_callback_mechanism"></a>Data callback mechanism</h2>
The most important use of the parser is of course to get the data out of
the GEDCOM file. &nbsp;As already mentioned, the parser uses a callback mechanism
for that. &nbsp;In fact, the mechanism involves two levels.<br>
      <br>
The primary level is that each of the sections in a GEDCOM file is notified
to the application code via a "start element" callback and an "end element"
callback (much like in a SAX interface for XML), i.e. when a line containing
a certain tag is parsed, the "start element" callback is called for that
tag, and when all its subordinate lines with their tags have been processed,
the "end element" callback is called for the original tag. &nbsp;Since GEDCOM
is hierarchical, this results in properly nested calls to appropriate "start
element" and "end element" callbacks.<br>
      <br>
However, it would be typical for a genealogy program to support only a subset
of the GEDCOM standard, certainly a program that is still under development.
&nbsp;Moreover, under GEDCOM it is allowed for an application to define its
own tags, which will typically not &nbsp;be supported by another application.
&nbsp;Still, in that case, data preservation is important; it would hardly
be accepted that information that is not understood by a certain program
is just removed.<br>
      <br>
Therefore, the second level of callbacks involves a "default callback". &nbsp;An
application needs to subscribe to callbacks for tags it does support, and
need to provide a "default callback" which will be called for tags it doesn't
support. &nbsp;The application can then choose to just store the information
that comes via the default callback in plain textual format.<br>
      <br>
After this introduction, let's see what the API looks like...<br>
      <br>
      <h3><a name="Start_and_end_callbacks"></a>Start and end callbacks</h3>
      <h4><i>Callbacks for records</i> <br>
      </h4>
As a simple example, we will get some information from the header of a GEDCOM
file. &nbsp;First, have a look at the following piece of code:<br>
      <blockquote><code>Gedcom_ctxt <b>my_header_start_cb</b> (int level,
Gedcom_val xref, char *tag)<br>
{<br>
&nbsp; printf("The header starts\n");<br>
&nbsp; return (Gedcom_ctxt)1;<br>
}<br>
        <br>
void <b>my_header_end_cb</b> (Gedcom_ctxt self)<br>
{<br>
&nbsp; printf("The header ends, context is %d\n", self); &nbsp; /* context
will print as "1" */<br>
}<br>
        <br>
...<br>
        <b>gedcom_subscribe_to_record</b>(REC_HEAD, my_header_start_cb, my_header_end_cb);<br>
...<br>
result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
        </blockquote>
   Using the <code>gedcom_subscribe_to_record</code> function, the application
requests to use the specified callbacks as start and end callback. The end
callback is optional: you can pass <code>NULL</code> if you are not interested
in the end callback. &nbsp;The identifiers to use as first argument to the
function (here <code>REC_HEAD</code>) are described in <i>TBD (use the header
file for now...)</i>.<br>
        <br>
From the name of the function it becomes clear that this function is specific
to complete records. &nbsp;For the separate elements in records there is
another function, which we'll see shortly. &nbsp;Again, the callbacks need
to have the signatures as shown in the example.<br>
        <br>
The <code>Gedcom_ctxt</code> type that is used as a result of the start callback
and as an argument to the end callback is vital for passing context necessary
for the application. &nbsp;This type is meant to be opaque; in fact, it's
a void pointer, so you can pass anything via it. &nbsp;The important thing
to know is that the context that the application returns in the start callback
will be passed in the end callback as an argument, and as we will see shortly,
also to all the directly subordinate elements of the record.<br>
        <br>
The example passes a simple integer as context, but an application could
e.g. pass a <code>struct</code> that will contain the information for the
header. &nbsp;In the end callback, the application could then e.g. do some
finalizing operations on the <code>struct</code> to put it in its database.<br>
        <br>
(Note that the <code>Gedcom_val</code> type for the <code>xref</code> argument
was not discussed, see further for this)<br>
        <br>
        <h4><i>Callbacks for elements</i></h4>
We will now retrieve the SOUR field (the name of the program that wrote the
file) from the header:<br>
        <blockquote><code>Gedcom_ctxt <b>my_header_source_start_cb</b>(Gedcom_ctxt
parent,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;
&nbsp; &nbsp; level,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* &nbsp; &nbsp;
&nbsp; tag,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char* &nbsp; &nbsp;
&nbsp; raw_value,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gedcom_val &nbsp;parsed_value)<br>
{<br>
&nbsp; char *source = GEDCOM_STRING(parsed_value);<br>
&nbsp; printf("This file was written by %s\n", source);<br>
&nbsp; return parent;<br>
}<br>
          <br>
void <b>my_header_source_end_cb</b>(Gedcom_ctxt parent,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;Gedcom_ctxt self,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;Gedcom_val &nbsp;parsed_value)<br>
{<br>
&nbsp; printf("End of the source description\n");<br>
}<br>
          <br>
...<br>
          <b>gedcom_subscribe_to_element</b>(ELT_HEAD_SOUR,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; my_header_source_start_cb,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; my_header_source_end_cb);<br>
...<br>
result = <b>gedcom_parse_file</b>("myfamily.ged");</code><br>
          </blockquote>
The subscription mechanism for elements is similar, only the signatures of
the callbacks differ. &nbsp;The signature for the start callback shows that
the context of the parent line (e.g. the <code>struct</code> that describes
the header) is passed to this start callback. &nbsp;The callback itself returns
here the same context, but this can be its own context object of course.
&nbsp;The end callback is called with both the context of the parent and
the context of itself, which will be the same in the example.<br>
          <br>
If we look at the other arguments of the start callback, we see the level
number (the initial number of the line in the GEDCOM file), the tag (e.g.
"SOUR"), and then a raw value and a parsed value. &nbsp;The raw value is
just the raw string that occurs as value on the line next to the tag (in
UTF-8 encoding). &nbsp;The parsed value is the meaningful value that is parsed
from that raw string.<br>
          <br>
The <code>Gedcom_val</code> type is meant to be an opaque type. &nbsp;The
only thing that needs to be known about it is that it can contain specific
data types, which have to be retrieved from it using pre-defined macros.
&nbsp;Currently, the specific types are (with <code>val</code> of type <code>
Gedcom_val</code>):<br>
          <br>
          <table cellpadding="2" cellspacing="2" border="1" width="100%">
            <tbody>
              <tr>
                <td valign="top"><br>
                </td>
                <td valign="top"><b>type checker</b><br>
                </td>
                <td valign="top"><b>cast operator</b><br>
                </td>
              </tr>
              <tr>
                <td valign="top">null value<br>
                </td>
                <td valign="top"><code>GEDCOM_IS_NULL(val)</code><br>
                </td>
                <td valign="top">N/A<br>
                </td>
              </tr>
              <tr>
                <td valign="top">string<br>
                </td>
                <td valign="top"><code>GEDCOM_IS_STRING(val)</code><br>
                </td>
                <td valign="top"><code>char* str = GEDCOM_STRING(val);</code><br>
                </td>
              </tr>
              <tr>
                <td valign="top">date<br>
                </td>
                <td valign="top"><code>GEDCOM_IS_DATE(val)</code><br>
                </td>
                <td valign="top"><code>struct date_value dv = GEDCOM_DATE(val)
;</code><br>
                </td>
              </tr>
            </tbody>
          </table>
          <br>
The null value is used for when the GEDCOM spec doesn't allow a value, or
when an optional value is allowed but none is given.<br>
&nbsp; <br>
The string value is the most general used value currently, for all those
values that don't have a more specific meaning. &nbsp;In essence, the value
that is returned by GEDCOM_STRING is always the same as the raw_value passed
to the start callback, and is thus in fact redundant.<br>
          <br>
The date value is used for all elements that return a date. &nbsp;(<i>Description
of struct date_value TBD: look in the header file for the moment</i>).<br>
          <br>
The type checker returns a true or a false value according to the type of
the value, but this is in principle only necessary in the rare circumstances
that two types are possible, or where an optional value can be provided.
&nbsp;In most cases, the type is fixed for a specific tag (<i>types per tag
to be described</i>).<br>
          <br>
Some extra notes:<br>
          <ul>
            <li>The <code>Gedcom_val</code> argument of the end callback
is currently not used. &nbsp;It is there for future enhancements.</li>
            <li>There is also a <code>Gedcom_val</code> argument in the start
callback for records. &nbsp;This argument is currently a string value giving
the pointer in string form.</li>
          </ul>
          <h3><a name="Default_callbacks"></a>Default callbacks<br>
          </h3>
TO BE COMPLETED<br>
          <hr width="100%" size="2">$Id$<br>
       $Name$<br>
   <br>
   
          </body>
          </html>
